<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>手撸AVL数</title><url>https://yinan-hong.github.io/post/avltree/</url><categories><category>数据结构</category><category>算法</category></categories><tags><tag>AVL树</tag><tag>平衡二叉树</tag><tag>数据结构</tag></tags><content type="html"> Wiki:在计算机科学中，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。
先丢个代码，周末再补原理介绍。
#include &lt;iostream>using namespace std; #define LH 1 // 左高 #define EH 0 // 等高 #define RH -1 // 右高 class BiNode { public: int key; // 关键值 int bf; // 平衡因子 BiNode* lChild, * rChild; BiNode(int kValue, int bValue) { key = kValue; bf = bValue; lChild = NULL; rChild = NULL; } ~BiNode() { key = 0; bf = 0; lChild = NULL; rChild = NULL; } }; // 二叉排序树 class BST { private: BiNode* root; // 根结点指针 void rRotate(BiNode*&amp; p); void lRotate(BiNode*&amp; p); void leftBalance(BiNode*&amp; t); void rightBalance(BiNode*&amp; t); int insertAVL(BiNode*&amp; t, int key, bool&amp; taller); // 插入元素并做平衡处理 void inOrder(BiNode* p); public: BST(); void insertAVL(int key); // 二叉排序树插入元素 ~BST(); void inOrder(); // 中序遍历 }; // 以p为根的二叉排序树作右旋处理 void BST::rRotate(BiNode*&amp; p) { BiNode* lc = p->lChild; p->lChild = lc->rChild; lc->rChild = p; p = lc; } // 以p为根的二叉排序树作左旋处理 void BST::lRotate(BiNode*&amp; p) { BiNode* rc = p->rChild; p->rChild = rc->lChild; rc->lChild = p; p = rc; } // t为根的二叉排序树作左平衡旋转处理 void BST::leftBalance(BiNode*&amp; t) { BiNode *l = t->lChild; switch (l->bf) { case LH: t->bf = l->bf = EH; rRotate(t); break; case RH: BiNode *lr = l->rChild; switch (lr->bf) { case LH: t->bf = RH; l->bf = EH; break; case EH: t->bf = l->bf = EH; break; case RH: t->bf = EH; l->bf = LH; break; } lr->bf = EH; lRotate(t->lChild); rRotate(t); } } // t为根的二叉排序树作右平衡旋转处理 void BST::rightBalance(BiNode*&amp; t) { BiNode* r = t->rChild; switch (r->bf) { case RH: t->bf = r->bf = EH; lRotate(t); break; case LH: BiNode* rl = r->lChild; switch (rl->bf) { case RH: t->bf = LH; r->bf = EH; break; case EH: t->bf = r->bf = EH; break; case LH: t->bf = EH; r->bf = RH; break; } rl->bf = EH; rRotate(t->rChild); lRotate(t); } } int BST::insertAVL(BiNode*&amp; t, int key, bool&amp; taller) { if (!t) { t = new BiNode(key, 0); taller = true; } else if (key == t->key) { //存在相同key节点，不再插入 taller = false; return 0; } else if (key &lt; t->key) { //搜寻左子树 if (!insertAVL(t->lChild, key, taller)) //未插入 return 0; if (taller) //插入成功则树“长高” switch (t->bf) { case LH: leftBalance(t); taller = false; break; //原本左侧高，左平衡处理 case EH:t->bf = LH; taller = true; break; //原本等高，现在左侧高 case RH:t->bf = EH; taller = false; break; //原本右侧高，现在等高 } } else { //搜寻右子树 if (!insertAVL(t->rChild, key, taller)) return 0; if(taller) switch (t->bf) { case LH:t->bf = EH; taller = false; break; case EH:t->bf = RH; taller = true; break; case RH:rightBalance(t); taller = false; break; } } return 1; } void BST::inOrder(BiNode* p) { if (p) { inOrder(p->lChild); cout &lt;&lt; p->key &lt;&lt; ':' &lt;&lt; p->bf &lt;&lt; ' '; inOrder(p->rChild); } return; } // 二叉排序树初始化 BST::BST() { root = NULL; } BST::~BST() { root = NULL; } // 插入元素并作平衡处理 void BST::insertAVL(int key) { bool taller = false; insertAVL(root, key, taller); } // 中序遍历 void BST::inOrder() { inOrder(root); } int main(void) { int t; cin >> t; while (t--) { // 构建二叉平衡树，并在插入元素时做平衡处理 int n, elem; cin >> n; BST tree; while (n--) { cin >> elem; tree.insertAVL(elem); } tree.inOrder(); cout &lt;&lt; endl; } return 0; } //https://www.jianshu.com/p/fdb3c8c331f1 /* 输入 第一行输入测试数据组数t； 每组测试数据，第一行输入结点数n, 第二行输入n个结点值。 输出 对每组测试数据，按中序遍历的顺序输出树中，结点值及平衡因子（测试数据没有空树），即结点值：平衡因子，不同结点之间间隔一个空格。 样例输入 8 3 64 5 1 3 64 5 13 6 64 78 5 1 13 15 6 64 78 5 1 13 10 3 64 78 100 3 64 80 70 6 64 30 80 90 70 68 6 64 30 80 90 70 75 样例输出 1:0 5:0 64:0 5:0 13:0 64:0 1:0 5:1 13:0 15:0 64:0 78:0 1:0 5:0 10:0 13:0 64:-1 78:0 64:0 78:0 100:0 64:0 70:0 80:0 30:0 64:0 68:0 70:0 80:-1 90:0 30:0 64:1 70:0 75:0 80:0 90:0 */</content></entry><entry><title>基于TCP协议的简易通讯程序</title><url>https://yinan-hong.github.io/post/fakeqq/</url><categories><category>小玩意</category></categories><tags><tag>Java</tag><tag>网络编程</tag><tag>TCP</tag></tags><content type="html"> Java课网络编程部分的一个小练习，用Socket类和ServerSocket类进行TCP编程，做一个简易的带图形界面的聊天工具。
Java课教的比较简单，风格是那种什么都讲一点，又什么都讲的很浅的那种。不过老师写了这本教材还是很不容易的，入门的初初学者可以用来当字典型的书了。
书上给了个Server、Client对话程序的例子，不过是很简单的在命令行显示，然后用终端输入来卡循环，所以只能一人发一句。
课本源码 // 客户端程序 package sample; import java.io.*; import java.net.*; public class TalkClient { public static void main(String args[]) { try{ Socket socket=new Socket("127.0.0.1",4700); //向本机的4700端口发出客户请求 BufferedReader sin=new BufferedReader(new InputStreamReader(System.in)); //由系统标准输入设备构造BufferedReader对象 PrintWriter os=new PrintWriter(socket.getOutputStream()); //由Socket对象得到输出流，并构造PrintWriter对象 BufferedReader is=new BufferedReader( new InputStreamReader(socket.getInputStream())); //由Socket对象得到输入流，并构造相应的BufferedReader对象 String readline; readline=sin.readLine(); //从系统标准输入读入一字符串 while(!readline.equals("bye")){ //若从标准输入读入的字符串为 "bye"则停止循环 os.println(readline); //将从系统标准输入读入的字符串输出到Server os.flush(); //刷新输出流，使Server马上收到该字符串 System.out.println("Client:"+readline); //在系统标准输出上打印读入的字符串 System.out.println("Server:"+is.readLine()); //从Server读入一字符串，并打印到标准输出上 readline=sin.readLine(); //从系统标准输入读入一字符串 } os.close(); //关闭Socket输出流 is.close(); //关闭Socket输入流 socket.close(); //关闭Socket }catch(Exception e) { System.out.println("Error"+e); //出错，则打印出错信息 } } } // 服务器端程序 package sample; import java.io.*; import java.net.*; import java.applet.Applet; public class TalkServer{ public static void main(String args[]) { try{ ServerSocket server=null; try{ //新建4700端口的服务端 server=new ServerSocket(4700); }catch(Exception e) { System.out.println("can not listen to:"+e); //出现异常则返回信息 } Socket socket=null; try{ socket=server.accept(); //连接客户端 }catch(Exception e) { System.out.println("Error."+e); //出现异常返回信息 } String line; BufferedReader is=new BufferedReader( new InputStreamReader(socket.getInputStream())); //由系统标准输入设备构造BufferedReader对象 PrintWriter os=new PrintWriter(socket.getOutputStream()); //由Socket对象得到输出流，并构造PrintWriter对象 BufferedReader sin=new BufferedReader(new InputStreamReader(System.in)); //由Socket对象得到输入流，并构造相应的BufferedReader对象 System.out.println("Client:"+is.readLine()); //从Client读入一字符串，并打印到标准输出上 line=sin.readLine(); //从系统标准输入读入字符串 while(!line.equals("bye")){ //若从标准输入读入的字符串为 "bye"则停止循环 os.println(line); //将从系统标准输入读入的字符串输出到Client os.flush(); //刷新输出流，使Server马上收到该字符串 System.out.println("Server:"+line); //在系统标准输出上打印读入的字符串 System.out.println("Client:"+is.readLine()); //从Server读入一字符串，并打印到标准输出上 line=sin.readLine(); //从系统标准输入读入一字符串 } os.close(); //关闭Socket输出流 is.close(); //关闭Socket输入流 socket.close(); //关闭Socket server.close(); //关闭ServerSocket }catch(Exception e){ System.out.println("Error:"+e); //捕获异常，输出错误信息 } } } 优化 我就简单改了下加了个线程，让它可以连续发送和接收。发送的线程50ms刷新一次，等发送信号（不设延时的话循环会跑的飞快，更改发送信号的线程没反应&hellip;）。接收消息的函数是会等待消息收到才会继续运行，就不用手动卡时间了。
图形界面是网上找的，删删改改了一下。
注释非常详尽，直接看源码吧~
精分现场简直笑死，再也不说编程没意思了hhhhh
代码 import java.io.*; import java.net.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.text.SimpleDateFormat; import java.util.Date; import javax.swing.*; import java.util.*; //图形界面 class Chat extends JFrame implements ActionListener { static boolean status = true; static boolean send = false; private JLabel label1, label2; private JTextField jTextField2; // 文本框 private JButton button2, button3; // 按钮 private JTextArea textArea; // 文本域 private JPanel southPanel; // 面板 // 日期格式化 ，后面接收消息方法receive会用到 private static SimpleDateFormat sdf2 = new SimpleDateFormat("a HH:mm:ss"); public Chat() { // 定义窗口宽高常量 final int width = 500; final int height = 600; // 获取屏幕尺寸 Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); JFrame myJFrame = new JFrame("Fake QQ"); // 设置窗口大小 myJFrame.setSize(width, height); // 设置窗口居中显示 myJFrame.setLocation(screenSize.width / 2 - width / 2, screenSize.height / 2 - height / 2); // 网格布局 this.setLayout(new BorderLayout()); label1 = new JLabel("SERVER", SwingConstants.RIGHT); //窗口顶部名称 JPanel innerPanelCenter = new JPanel(); JPanel innerPanel = new JPanel(); innerPanel.add(label1); innerPanelCenter.add(innerPanel); label2 = new JLabel("快开始聊天吧!"); label2.setForeground(Color.red); label2.setBorder(BorderFactory.createTitledBorder("提示")); JPanel northPanel = new JPanel(new BorderLayout()); northPanel.add(innerPanelCenter, BorderLayout.CENTER); northPanel.add(label2, BorderLayout.SOUTH); myJFrame.add(northPanel, BorderLayout.NORTH); textArea = new JTextArea(); textArea.setLineWrap(true); textArea.setWrapStyleWord(true); textArea.setFont(new Font("幼圆", Font.PLAIN, 16)); myJFrame.add(new JScrollPane(textArea), BorderLayout.CENTER); southPanel = new JPanel(); southPanel.add(new JLabel()); jTextField2 = new JTextField(30); southPanel.add(jTextField2); button2 = new JButton("发送"); southPanel.add(button2); button3 = new JButton("退出"); southPanel.add(button3); button2.addActionListener(this); button3.addActionListener(this); myJFrame.add(southPanel, BorderLayout.SOUTH); // 设置窗口可见 myJFrame.setVisible(true); } public void actionPerformed(ActionEvent e) { if (e.getSource() == button2) { send(); // 发送 } if (e.getSource() == button3) { status = false; System.exit(0); // 退出 } } public void send() { // 设置发送信号 send = true; } public void onscreen(String person, String str) { // 图形界面输出 textArea.append((sdf2.format(new Date())) + "\n" + person + ": " + str + "\n\n"); } public String getText() { String str = jTextField2.getText(); jTextField2.setText(""); // 清空输入栏 return str; } } // 服务端 public class TalkServer { public static void main(String args[]) { try { Chat chat = new Chat(); // 创建图形界面实例 ServerSocket server = null; // 创建socket try { server = new ServerSocket(4701); } catch (Exception e) { System.out.println("can not listen to:" + e); } Socket socket = null; try { socket = server.accept(); // 等待客户端接入 } catch (Exception e) { System.out.println("Error." + e); } PrintWriter os = new PrintWriter(socket.getOutputStream()); BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream())); class Send extends Thread { // 发送线程 public void run() { os.println("connected"); os.flush(); String str = null; while (Chat.status) { // status由图形界面关闭按钮控制 System.out.println("waiting to send"); // 命令行输出状态 while (!Chat.send) { // 等待发送信号 try { Thread.sleep(50); // 每50ms刷新状态 } catch (InterruptedException e) { e.printStackTrace(); } } Chat.send = false; // 重置等待信号 str = chat.getText(); // 获取发送框文本 chat.onscreen("You", str); // 显示发送内容 try { os.println(str); // 发送 os.flush(); } catch (Exception e) { System.out.println("Sending error." + e); } } } } Send SendingThread = new Send(); // 创建并启动线程 SendingThread.start(); // 接收设在主线程，**不知道为什么创建新线程is.readLine()会出现异常** String str; while (Chat.status) { System.out.println("waiting to receive"); // 命令行输出状态 str = is.readLine(); // 等待接收 System.out.println("Client:" + str); // 命令行显示接收内容 chat.onscreen("Client", str); // 图形界面显示接收内容 } os.close(); // 关闭Socket输出流 is.close();// 关闭Socket输入流 socket.close(); // 关闭Socket server.close(); } catch (IOException e) { e.printStackTrace(); System.out.println("error"); } } } // 客户端 public class TalkClient { public static void main(String args[]) { try { Chat chat = new Chat(); // 创建图形界面实例 System.out.println("111"); Socket socket = new Socket("127.0.0.1", 4701); // 创建socket，接入终端 PrintWriter os = new PrintWriter(socket.getOutputStream()); BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream())); class Send extends Thread { // 发送线程 public void run() { os.println("connected"); os.flush(); String str = null; while (Chat.status) { // status由图形界面关闭按钮控制 System.out.println("waiting to send"); // 命令行输出状态 while (!Chat.send) { // 等待发送信号 try { Thread.sleep(50); // 每50ms刷新状态 } catch (InterruptedException e) { e.printStackTrace(); } } Chat.send = false; // 重置等待信号 str = chat.getText(); // 获取发送框文本 chat.onscreen("You", str); // 显示发送内容 try { os.println(str); // 发送 os.flush(); } catch (Exception e) { System.out.println("Sending error." + e); } } } } Send SendingThread = new Send(); // 创建并启动线程 SendingThread.start(); // 接收设在主线程，**不知道为什么创建新线程is.readLine()会出现异常** String str; while (Chat.status) { System.out.println("waiting to Receive"); // 命令行输出状态 str = is.readLine(); // 等待接收 System.out.println("Server:" + str); // 显示接受内容 chat.onscreen("Server", str); // 图形界面显示接收内容 } os.close(); // 关闭Socket输出流 is.close();// 关闭Socket输入流 socket.close(); // 关闭Socket } catch (IOException e) { e.printStackTrace(); System.out.println("error"); } } }</content></entry><entry><title>微信图片dat格式解码</title><url>https://yinan-hong.github.io/post/wechatpicdecrypt/</url><categories><category>小工具</category></categories><tags><tag>图片解码</tag></tags><content type="html"> PC端微信会把图片保存为.dat格式，实际上是对图片的16进制编码进行了简单的异或加密。本文简单分析一下加密原理，然后提供一个常见图片格式解码的python实现。
问题背景 事情是这样的&hellip;
有一天想找一个远古聊天记录里的照片，因为我换了手机，所以只能在pc端慢慢往上翻到去年的记录&hellip; 于是我就想，图片肯定会存在本地的呀，打开文件发现微信保存的格式是没见过的.dat，于是我打开了百度&hellip;
其实下面讲的原理和方法都是参考了网上dalao们发过的，我就是整合了一下，代码优化了下，加了点细节，然后又可以水一篇文章哈哈哈。
太长不看版 对于没有编程能力或者对原理不感兴趣的同学，我贴心地封装了可执行文件，下载下来就可以直接运行了。
Yinan-Hong/WechatPicDecrypt (github.com)
GG，因为调用了os库，所以封装的可执行文件会被windows当成木马查杀。要怎么解决我有空再搞吧我要睡觉了&hellip;. QwQ
// todo
微信的文件存储 PC端的微信，点开后的图片会被下载到本地，没点开的只会存高糊的预览图。微信的文件会存储在你设定的文件夹里，默认是在C盘安装微信的位置，可以在微信左下角【设置】→【文件管理】查看文件存储目录。
打开目录下名为【WeChat Files】的目录，里面会有以【微信号】命名的目录，里面存的就是这个微信号的聊天文件，包括文本，发送的文件，图片，表情包之类的。进入【FileStorage】→【Image】，里面是按月份分的聊天记录内下载过的图片。文件是后缀是.dat格式，只有在客户端用微信自带的图片查看器才能正常打开。
加密原理 用16进制编辑器打开dat文件，发现每个文件的前十几个字节都是一样的。因为jpg、png文件开头都是固定的，比如jpg文件前两个字节是0xFF, 0xD8，所以猜测这个加密方式是对每个字节用密码进行异或。
将文件前两个字节0x07, 0x20与jpg文件的前两个字节0xFF, 0xD8进行异或
运算结果都为0xF8，所以猜测加密密码是0xF8。也就是说这个是将文件的每两字节与0xF8异或，然后将文件保存为.dat后缀的文件。实际上这个文件就是这样加密的，只是每个用户的加密密码是不一样的。
解码程序思路 首先要输入文件夹的绝对地址，然后遍历里面的每一个文件。
因为发现目录下可能有些其他格式的配置文件，所以判断一下文件后缀不是.dat的跳过。
对dat文件，分别取jpg，png，gif（这三个格式比较常见，所以只做了这三个的）的前四个字节，【前两位】与【jpg的前两字节】异或得到两位【十六进制数1】，【第三第四字节】与【jpg的第三第四字节】异或得到两位【十六进制数2】。如果得到的【十六进制数1】等于【十六进制数2】，那就能判断原文件的格式是jpg，并且得到了加密密码就是【十六进制数1】。
得到密码后，将文件解码，保存为.jpg文件，然后输出到目录下名为output的文件夹。
代码 import os ''' jpg文件的前两个字节为 pic_head[0], pic_head[1] png为[2],[3] gif为[4],[5] ''' pic_head = [0xff, 0xd8, 0x89, 0x50, 0x47, 0x49] decode_code = 0 # 解密码 #判断文件类型，并获取dat文件解密码 def get_code(file_path): # file_path: dat文件路径 dat_file = open(file_path, "rb") dat_read = dat_file.read(2) head_index = 0 while head_index &lt; len(pic_head): #使用第一个头信息字节来计算加密码 code = dat_read[0] ^ pic_head[head_index] idf_code = dat_read[1] ^ code head_index = head_index + 1 #第二个字节来验证解密码是否正确 if idf_code == pic_head[head_index]: dat_file.close() return code head_index = head_index + 1 #如果解码成功，则返回解密码，如果文件不是这三种格式则返回0 print("not jpg, png, gif") return 0 def decrypt(file_name, file_path, output_file): #dat文件路径，生成文件路径 #获取密码 decode_code = get_code(file_path) dat_file = open(file_path, "rb") pic_name = output_file + ".jpg" pic_write = open(pic_name, "wb") #解码 for dat_data in dat_file: for dat_byte in dat_data: pic_data = dat_byte ^ decode_code pic_write.write(bytes([pic_data])) print(file_name + "---解码成功") dat_file.close() pic_write.close() def mkdir(path): path=path.strip() # 去除尾部 \ 符号 path=path.rstrip("\\") # 判断路径是否存在 isExists=os.path.exists(path) if not isExists: # 如果不存在则创建目录 # 创建目录操作函数 os.makedirs(path) print (path + ' 目录创建成功') return True else: # 如果目录存在则不创建，并提示目录已存在 print (path + ' 目录已存在') return False def find_datfile(dir_path): #获取dat文件目录下所有的文件 files_list = os.listdir(dir_path) output_path = dir_path + "\output" #在原目录下新建一个output目录 mkdir(output_path) cnt = 0 succeed = 0 #对每个文件获取文件名然后解码 for file_name in files_list: #判断文件后缀是否为.dat cnt = cnt + 1 file_type = file_name[-4:] if(file_type!=".dat"): print(file_name + '---文件不是.dat格式') continue file_path = dir_path + "\\" + file_name output_file = output_path + "\\" +file_name decrypt(file_name, file_path, output_file) succeed = succeed + 1 print("==================") print("All done!") print ("目录下文件共", cnt, "个，成功解码", succeed, "个。") print("==================") path = input("请输入微信dat文件的目录（绝对路径）:") find_datfile(path) 运行示例 运行前的文件夹，有三个.dat文件，有一个不是
运行程序
输入目录路径
运行后的文件夹
写在最后 其实这个是大半年前遇到的问题，当时网上搜到了比较方便的在线解码器。但是那时候想想，都学计算机了，要不试试像程序员一样去解决问题，于是就搜了更多方法。
本文的内容参考了一些博客，只要搜微信dat文件之类的关键词就能搜到很多，不少人很早之前就遇到并解决了这个问题。不过这是我第一次用编程的方法解决我遇到的实际问题，感觉非常有纪念意义，值得写这么一篇东西记录一下哈哈。</content></entry><entry><title>关于我</title><url>https://yinan-hong.github.io/about.html</url><categories/><tags/><content type="html"> 年级 大二在读
教育经历 深圳中学2019届
深圳技术大学2023届物联网工程专业
学习方向 C/C++后台开发
游戏开发
爱好 唱歌、弹琴、吉他、美剧、漫威（资深漫威粉）、王者荣耀
梦想 世界和平
小目标 去腾讯开发王者荣耀
长得 很帅
本站介绍 有一天心血来潮，想做个网站放放自己的作品和学习经历什么的，也方便我35岁失业后转行搞自媒体。于是五一捣鼓了一天弄出了这么个东西，感谢上一位优化这个主题的dalao慷慨开源。
网站用到的技术 本站用的是一个叫Hugo的静态网页生成工具，据说是用Go语言写的，所以理论上比大家常用的一些Hexo之类的可能速度要快一点，但比较小众所以功能可能有些不太全，出了问题只能上英文网站查&hellip;
网站主题用的是Next，很简洁很苹果，我很喜欢。Anyway，页面最下方有指向Hugo和next主题的链接，左侧sidebar有优化这个主题的github，有兴趣的朋友可以自行了解下。等我捣鼓明白了再写一篇关于制作个人主页的教程。
关于我 我是万万没想到会学计算机方向的，我喜欢的是生物，但家里没矿学不起。因为高考考了个很尴尬的分，种种考虑下还是到了深技大的物联网专业。
上大学之前我是完完全全没有接触过编程方面的知识的，硬要说有就是高中的电脑课教过c++，但那个课是教三样东西（另外两个是pr和产品设计），取成绩最好的两项算成绩。反正当时考试敲个算闰年的程序，我愣是一行都没敲出来，然后旁边的文科生朋友很快就写完了&hellip;. 所以说程序语言应该算语言学&hellip;
Anyway&hellip; 我感觉学校对我们专业的定位不是很明确，然后需要花大量时间学硬件相关的课程，我按学校的学习进度应该会比同期的计算机专业的同学要慢上不少，而且乱上不少。我在学习的时候，时常会遇到一些比入门问题要难一点，但是也没难到哪里去的问题。周围很少有能一起讨论的同学，所以我总是会在一些很蠢的问题上卡很长时间。
关于本站的文章 所以我打算写一些技术文章，记录一下学习过程中遇到过的比较难的知识or技术。然后这学期在上数据结构与算法，如果做到什么有意思的题目，或者我有什么清奇的思路，也会写一篇题解之类的文章。
我目前的水平也就这样了，我会尽量把我搞懂了的东西写清楚，希望能帮到比我菜的同学。等以后我牛逼了一定会写更多有技术含量的文章来回馈开源社区！
除了编程相关之外，我还会写一些键政文章。我觉得中国的教育缺失对学生社会责任感的培养，作为社会中的一个个体，我们应该承担自己的社会责任，要有推动社会进步的意识。我很幸运在深圳中学遇到了很多有思想，有担当的青年同学和教师。在ta们的影响下我开始关注时事，并乐于分享自己的思考。说白了就是，学什么都救不了中国人，所以我只能拿起手中的键盘&hellip;</content></entry><entry><title>最优二叉树和赫夫曼编码</title><url>https://yinan-hong.github.io/post/huffmantree/</url><categories><category>算法</category><category>数据结构</category></categories><tags><tag>最优二叉树</tag><tag>二叉树</tag><tag>算法</tag></tags><content type="html"> 节点的带权路径长度是指根节点到该节点的路径长度与节点权值的乘积。最优二叉树（赫夫曼树or哈夫曼树）是指带权路径和最小的二叉树。构建赫夫曼树时，要使带权路径和最小，需要遵循权重大的节点离根节点更近。
构建赫夫曼树 有给定权值的n个节点：
在n个节点中选出两个权值最小的节点，将两个节点组成一个二叉树，根结点的权值为左右子节点权值的和。
将上一步的根节点放入剩下的节点中，进行 1 。
赫夫曼编码 问题： 请设计变长的前缀码，对消息DEAACAAAAABA进行编码
对消息DEAACAAAAABA进行编码的前缀码编码方案很多，比如用ascii码之类的但是会很长因，因为每个字母的ascii码都要占1个byte。
消息中字符 A 出现了8次，字符 B、C、D 和 E 均只出现了1次；字符 A 用一个bit位表示，A=0，其他字符的编码均不能以0开头；
B=10、C=11、D=110和 E=111
DEAACAAAAABA=110111001100000100。这样得到比较短的编码。
编码规则 原文链接：哈夫曼编码详解——图解真能看了秒懂_Young_IT的博客-CSDN博客
直接上题目: 已知字符集 { a, b, c, d, e, f }， 若各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }， 则对应字符集中各字符的哈夫曼编码可能是：(2分) A. 00, 1011, 01, 1010, 11, 100 B. 00, 100, 110, 000, 0010, 01 C. 10, 1011, 11, 0011, 00, 010 D. 0011, 10, 11, 0010, 01, 000 步骤一： 1.找最小两个次数（这里是2和3）
2.把他们放进树中（小左大右）
3.每次组合都多一个父节点（即2+3=5）
步骤二： 1.再选出2个最小的数（排除上面已经选了的）——选出了4和6
2.因为4&lt;5 , 6>5（5为步骤一中组合后的父节点）
3.单独拿4来跟5组合（小左大右） 【如果拿出的2个数都比5小，则这2个数自己组合后跟5组合，下面提到】
####　步骤三： 1.因为步骤二用掉了4，还没用6。现在取最小2个数
2.因为6 &lt; 9 , 8&lt; 9 所以6和8自己组合（小左大右） （组合后先放一边）
步骤四： 1.取出最后10
2.10要和这两个子树根节点最小的组合（9&lt;14,所以和9组合）（小左大右）
3.然后把14的子树组合上去（小左大右） 所以放左边
步骤五： 组合完哈夫曼树后,将对应的字符填上去
步骤六： 从根节点开始向下走往左为0，往右1。走到对应的字符的路径就是该字符的哈夫曼编码（左0右1）
最后结果： 字符 赫夫曼编码 a 00 b 1011 c 01 d 1010 e 11 f 100 所以最后答案 A 已知字符集{ a, b, c, d, e, f }， 若各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }， 则对应字符集中各字符的哈夫曼编码可能是：(2分) A. 00, 1011, 01, 1010, 11, 100 ✔ B. 00, 100, 110, 000, 0010, 01 C. 10, 1011, 11, 0011, 00, 010 D. 0011, 10, 11, 0010, 01, 000 版权声明：本文为CSDN博主「Young_IT」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Young_IT/article/details/106730343
参考代码 输入 第一行输入t，表示有t个测试实例 第二行先输入n，表示第1个实例有n个权值，接着输入n个权值，权值全是小于1万的正整数 依此类推
输出 逐行输出每个权值对应的编码，格式如下：权值-编码 即每行先输出1个权值，再输出一个短划线，再输出对应编码，接着下一行输入下一个权值和编码。 以此类推
样例输入 1 5 15 4 4 3 2 样例输出 15-1 4-010 4-011 3-001 2-000 实现代码 const int MaxW = 9999999; // 假设结点权值不超过9999999 // 定义huffman树结点类 class HuffNode { public: int weight; // 权值 int parent; // 父结点下标 int leftchild; // 左孩子下标 int rightchild; // 右孩子下标 }; // 定义赫夫曼树类 class HuffMan { private: void MakeTree(); // 建树，私有函数，被公有函数调用 void SelectMin(int pos, int* s1, int* s2); // 从 1 到 pos 的位置找出权值最小的两个结点，把结点下标存在 s1 和 s2 中 public: int len; // 结点数量 int lnum; // 叶子数量 HuffNode* huffTree; // 赫夫曼树，用数组表示 string* huffCode; // 每个字符对应的赫夫曼编码 void MakeTree(int n, int wt[]); // 公有函数，被主函数main调用 void Coding(); // 公有函数，被主函数main调用 void Destroy(); }; // 构建huffman树 void HuffMan::MakeTree(int n, int wt[]) { // 参数是叶子结点数量和叶子权值 // 公有函数，对外接口 int i; lnum = n; len = 2 * n - 1; huffTree = new HuffNode[2 * n]; huffCode = new string[lnum + 1]; // 位置从 1 开始计算 // huffCode实质是个二维字符数组，第 i 行表示第 i 个字符对应的编码 // 赫夫曼树huffTree初始化 for (i = 1; i &lt;= n; i++) huffTree[i].weight = wt[i - 1]; // 第0号不用，从1开始编号 for (i = 1; i &lt;= len; i++) { if (i > n) huffTree[i].weight = 0; // 前n个结点是叶子，已经设置 huffTree[i].parent = 0; huffTree[i].leftchild = 0; huffTree[i].rightchild = 0; } MakeTree(); // 调用私有函数建树 } void HuffMan::SelectMin(int pos, int* s1, int* s2) { // 找出最小的两个权值的下标 // 函数采用地址传递的方法，找出两个下标保存在 s1 和 s2 中 int w1, w2, i; w1 = w2 = MaxW; // 初始化w1和w2为最大值，在比较中会被实际的权值替换 *s1 = *s2 = 0; for (i = 1; i &lt;= pos; i++) { // 比较过程如下： // 如果第 i 个结点的权值小于 w1，且第 i 个结点是未选择的结点，提示：如果第 i 结点未选择，它父亲为 0 // 把第 w1 和 s1 保存到 w2 和 s2，即原来的第一最小值变成第二最小值 // 把第 i 结点的权值和下标保存到 w1 和 s1，作为第一最小值 // 否则，如果第 i 结点的权值小于 w2，且第 i 结点是未选择的结点 // 把第 i 结点的权值和下标保存到 w2 和 s2，作为第二最小值 if (w1 > huffTree[i].weight &amp;&amp; !huffTree[i].parent) { w2 = w1; *s2 = *s1; w1 = huffTree[i].weight; *s1 = i; } else if (w2 > huffTree[i].weight &amp;&amp; !huffTree[i].parent) { w2 = huffTree[i].weight; *s2 = i; } } } void HuffMan::MakeTree() { // 私有函数，被公有函数调用 int i, s1, s2; for (i = lnum + 1; i &lt;= len; i++) { SelectMin(i - 1, &amp;s1, &amp;s2); // 找出两个最小权值的下标放入 s1 和 s2 中 huffTree[s1].parent = huffTree[s2].parent = i; huffTree[i].leftchild = s1; huffTree[i].rightchild = s2; huffTree[i].weight = huffTree[s1].weight + huffTree[s2].weight; // 将找出的两棵权值最小的子树合并为一棵子树，过程包括 // 结点 s1 和结点 s2 的父亲设为 i // 结点 i 的左右孩子分别设为 s1 和 s2 // 结点 i 的权值等于 s1 和 s2 的权值和 } } // 赫夫曼编码 void HuffMan::Coding() { char* cd; int i, c, f, start; // 求 n 个结点的赫夫曼编码 cd = new char[lnum]; // 分配求编码的工作空间 cd[lnum - 1] = '\0'; // 编码结束符 for (i = 1; i &lt;= lnum; ++i) { // 逐个字符求赫夫曼编码 start = lnum - 1; // 编码结束符位置 // 参考课本P147算法6.12 HuffmanCoding代码 for (c = i, f = huffTree[i].parent; f != 0; c = f, f = huffTree[f].parent) if (huffTree[f].leftchild == c) cd[--start] = '0'; else cd[--start] = '1'; huffCode[i].assign(&amp;cd[start]); // 把cd中从start到末尾的编码复制到huffCode中 } delete[]cd; // 释放工作空间 } // 销毁赫夫曼树 void HuffMan::Destroy() { len = 0; lnum = 0; delete[]huffTree; delete[]huffCode; } // 主函数 int main() { int t, n, i, j; int wt[800]; cin >> t; HuffMan myHuff; for (i = 0; i &lt; t; i++) { cin >> n; for (j = 0; j &lt; n; j++) cin >> wt[j]; myHuff.MakeTree(n, wt); myHuff.Coding(); for (j = 1; j &lt;= n; j++) { cout &lt;&lt; myHuff.huffTree[j].weight &lt;&lt; '-'; // 输出各权值 cout &lt;&lt; myHuff.huffCode[j] &lt;&lt; endl; // 输出各编码 } myHuff.Destroy(); } return 0; } 解码参考代码 输入 第一行输入t，表示有t个测试实例 第二行先输入n，表示第1个实例有n个权值，接着输入n个权值，权值全是小于1万的正整数 第三行输入n个字母，表示与权值对应的字符 第四行输入k，表示要输入k个编码串 第五行起输入k个编码串 以此类推输入下一个示例
输出 每行输出解码后的字符串，如果解码失败直接输出字符串“error”，不要输出部分解码结果
样例输入 2 5 15 4 4 3 2 A B C D E 3 11111 10100001001 00000101100 4 7 5 2 4 A B C D 3 1010000 111011 111110111 样例输出 AAAAA ABEAD error BBAAA error DCD 实现代码 只需在上文赫夫曼树实现代码中加入 Coding 方法和 Decoding 方法的实现。
//解码方法 int HuffMan::Decode(const string codestr, char txtstr[]) { int i, k, c; char ch; c = len; k = 0; for (i = 0; i &lt; codestr.length(); i++) { ch = codestr[i]; if (ch == '0') { c = huffTree[c].leftchild; } else if (ch == '1') { c = huffTree[c].rightchild; } else { return -1; } if (huffTree[c].leftchild == 0 &amp;&amp; huffTree[c].rightchild == 0) { txtstr[k++] = huffTree[c].cha; c = len; } else { ch = '\0'; } } if (ch == '\0') return -1; else txtstr[k] = '\0'; return 1; } //主函数 int main() { int t, n, i, j, m; int wt[800]; char ct[800]; HuffMan myHuff; cin >> t; for (i = 0; i &lt; t; i++) { cin >> n; string codestr; char txtstr[800]; for (j = 0; j &lt; n; j++) { cin >> wt[j]; } for (j = 0; j &lt; n; j++) { cin >> ct[j]; } myHuff.MakeTree(n, wt, ct); myHuff.Coding(); cin >> m; while (m--) { cin >> codestr; if (myHuff.Decode(codestr, txtstr) == 1) { cout &lt;&lt; txtstr &lt;&lt; endl; } else { cout &lt;&lt; "error" &lt;&lt; endl; } } myHuff.Destroy(); } return 0; } 一道算法题 赫夫曼编码长度 题目描述 每行一个大小写英文字母组成的字符串，长度不大于 1000，通过前缀编码后最短的编码长度。
输入 第一行输入一个整数t，表示有t组测试数据；
接下来输入t组测试数据，每组数据一行，大小写英文字母。
输出 每组数据输出赫夫曼编码长度
样例输入 4 AABBCCDEEEE AAABCCC BBACB tPvlQHFbPN 样例输出 25 11 7 32 题目解析 ` 本题如果真要用哈夫曼来建树，计算值会非常复杂。
首先要能够发现规律：哈夫曼树的编码长度等于各个叶节点权值与路径长度乘积之和，同时这个值等于非叶节点之和。
采用优先队列模拟哈夫曼树的建立。采用map记录字符与出现的次数，将每个字符的次数依次加入优先队列（数值小的在队头），每一次从队列中出队最小的两个，相加后再加入队列中。用ans记录每一次相加和temp值之和，当队列中剩下一个元素时，ans的值即为所求
知识点： priority_queue 优先队列：
priority_queue&lt;int>q; 默认为数字（字典序）大的值在队首top，等价于priority_queue&lt;int, vector&lt;int>, less&lt;int> >q;
priority_queue&lt;int, vector&lt;int>, greater&lt;int> >q; 表示数字（字典序）小的在队首
版权声明：本文为CSDN博主「julia7_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_35093872/article/details/88055475
AC代码 #include &lt;iostream>#include &lt;string>#include &lt;cstring>#include &lt;queue>#include &lt;map>using namespace std; const int maxn = 100; int main() { int t; cin >> t; while (t--) { string str; map&lt;char, int> mp; priority_queue&lt;int, vector&lt;int>, greater&lt;int> >q; cin >> str; int len = str.length(); for (int i = 0; i &lt; len; i++) { if (mp.find(str[i]) == mp.end()) { mp[str[i]] = 1; } else { mp[str[i]]++; } } for (map&lt;char, int>::iterator it = mp.begin(); it != mp.end(); it++) { q.push(it->second); } int ans = 0; while (q.size() != 1) { int a, b, temp; a = q.top(); q.pop(); b = q.top(); q.pop(); temp = a + b; ans += temp; q.push(temp); } cout &lt;&lt; ans &lt;&lt; endl; } return 0; }</content></entry><entry><title>二叉树从0到1</title><url>https://yinan-hong.github.io/post/binarytree/</url><categories><category>算法</category><category>数据结构</category></categories><tags><tag>二叉树</tag><tag>算法</tag></tags><content type="html"> 本文介绍关于二叉树的一些基本概念，典型操作，和我做过的比较入门的算法题。所以本文比较适合初学算法的同学，或者用来快速复习什么的。如果是对二叉树的算法比较熟悉的同学，建议可以直接去刷相关的算法题。
二叉树概念 二叉树就是每个节点最多有两个子节点的树。每个节点的内存大小包括【要存储的数据】、【指向子节点的两个指针】。
需要了解的几个概念，图中Tree 1就是一般的二叉树，Tree 2是完全二叉树，Tree 3是满二叉树。完全二叉树除最下面一层，其余层的节点个数必须达到最大，最底层节点全部靠左排列。满二叉树则是所有层的结点个数都需达到最大，显然满二叉树都是完全二叉树。
像上图的数据结构中，发现6、8、9号位置都没有存到数据，会有空间的浪费。而用完全二叉树存储就可以避免这样的问题。实际上所有的树结构都是可以转化成完全二叉树的。
二叉树的遍历操作 遍历就是逐个访问所有节点，而根据访问根节点和左右子节点顺序的不同，二叉树的遍历分为前序、中序、后序遍历。如果把一个运算式的字符串存入二叉树，按照中序输出得到"1+2*3-4"这样的中缀表达式，那按照前序输出就会得到它的波兰式，按后序输出就会得到它的逆波兰式。
前序遍历 前序遍历就是先访问根节点，再访问左子节点，再访问右子节点。上图的输出结果为ABDEGHCF。一些简单的算法题会给出前序遍历的数据，需要通过前序遍历的数据建立二叉树，然后进行其他二叉树的访问操作。
前序遍历的代码（递归实现）很简单：
void pre_order(Node* n) { if (n != NULL) { cout &lt;&lt; n->data &lt;&lt; ' '; //访问本节点数据 pre_order(n->left); pre_order(n->right); } } 中序遍历 中序遍历是先访问左子节点，再访问根节点，再访问右子节点。按上面同一棵树的输出结果应为DBGEHACF，图我就不画了太麻烦了&hellip;代码的区别其实就是换一下顺序。
void in_order(Node* n) { if (n != NULL) { pre_order(n->left); cout &lt;&lt; n->data &lt;&lt; ' '; //访问本节点数据 pre_order(n->right); } } 后序遍历 后序遍历是先访问左右节点，最后访问根节点。上面那棵树的后序输出为DGHEBFCA。
void in_order(Node* n) { if (n != NULL) { pre_order(n->left); pre_order(n->right); cout &lt;&lt; n->data &lt;&lt; ' '; //访问本节点数据 } } 逐层遍历 逐层遍历的意思是从左到右访问每一层的每一个节点。还是上面那颗树，逐层输出就是ABCDEFGH。逐层输出要用到队列，每一层的节点会先被放入队列，访问每一个节点时，将子节点放入队尾。每次循环取出队首的节点，就能实现从上到下，从左到右访问所有节点。
#include &lt;queue>void BinaryTree::level_order() { if (root == NULL) return; queue&lt;Node*> q; q.push(root); while (!q.empty()) { Node* n; n = q.front(); //取出队首的节点 q.pop(); cout &lt;&lt; n->data &lt;&lt; ' '; //访问节点数据 if (n->left != NULL) q.push(n->left); //将当前节点的左右子节点放入队列 if (n->right != NULL) q.push(n->right); } } 我写的一个二叉树模板类 因为想着这样不用改很多代码就可以实现存不同数据类型二叉树，所以就无聊写了个模板。这个类实现了二叉树中后序遍历，层序遍历，计算高度这些常用操作。
#include &lt;iostream>#include &lt;string>#include &lt;queue>using namespace std; template &lt;typename T> class Node { public: T data; Node* left; //左子节点 Node* right; //右子节点 }; template &lt;typename T> class BinaryTree { private: Node&lt;T>* root; //根节点 int height; //高度 Node&lt;T>* create_tree(const T* s, int&amp; pos, int s_len); void pre_order(Node&lt;T>* n); void in_order(Node&lt;T>* n); void post_order(Node&lt;T>* n); void level_order(Node&lt;T>* n); void get_height(Node&lt;T>* n, int h); //计算高度 public: BinaryTree(); void create_tree(const T* s, int s_len); void pre_order(); //前序遍历 void in_order(); //中序遍历 void post_order(); //后序遍历 void level_order(); //层序遍历 int get_height(); //获取高度 void ancestor(char A, char B); //todo求两个节点的最大公共祖先 }; template &lt;typename T> BinaryTree&lt;T>::BinaryTree() { root = NULL; height = -1; } template &lt;typename T> Node&lt;T>* BinaryTree&lt;T>::create_tree(const T* s, int&amp; pos, int s_len) { ++pos; Node&lt;T>* n; if (pos >= s_len) return NULL; else { if (s[pos] == '#') //该位置没有节点 n = NULL; else { n = new Node&lt;T>; n->data = s[pos]; n->left = create_tree(s, pos, s_len); n->right = create_tree(s, pos, s_len); } return n; } } template &lt;typename T> void BinaryTree&lt;T>::create_tree(const T* s, int s_len) { int pos = -1; } template &lt;typename T> void BinaryTree&lt;T>::pre_order() { //在公有接口中访问数据，保证私有数据的封装 pre_order(root); cout &lt;&lt; endl; } template &lt;typename T> void BinaryTree&lt;T>::pre_order(Node&lt;T>* n) { if (n != NULL) { //do sth cout &lt;&lt; n->data &lt;&lt; ' '; pre_order(n->left); pre_order(n->right); } } template &lt;typename T> void BinaryTree&lt;T>::in_order() { in_order(root); cout &lt;&lt; endl; } template &lt;typename T> void BinaryTree&lt;T>::in_order(Node&lt;T>* n) { if (n != NULL) { in_order(n->left); //do sth cout &lt;&lt; n->data &lt;&lt; ' '; in_order(n->right); } } template &lt;typename T> void BinaryTree&lt;T>::post_order() { post_order(root); cout &lt;&lt; endl; } template &lt;typename T> void BinaryTree&lt;T>::post_order(Node&lt;T>* n) { if (n != NULL) { post_order(n->left); post_order(n->right); //do sth cout &lt;&lt; n->data &lt;&lt; ' '; } } //用队列进行层序遍历 template &lt;typename T> void BinaryTree&lt;T>::level_order() { if (root == NULL) return; queue&lt;Node&lt;T>*>q; q.push(root); while (!q.empty()) { Node&lt;T>* n; n = q.front(); q.pop(); //do sth cout &lt;&lt; n->data &lt;&lt; ' '; if (n->left != NULL) q.push(n->left); if (n->right != NULL) q.push(n->right); } //do sth cout &lt;&lt; endl; } template &lt;typename T> int BinaryTree&lt;T>::get_height() { if (height == -1) get_height(root, 0); return height; } template &lt;typename T> void BinaryTree&lt;T>::get_height(Node&lt;T>* n, int h) { if (n != NULL) { ++h; if (h > height) height = h; get_height(n->left, h); get_height(n->right, h); } } int main() { //数据类型为char，#表示此处没有节点 string s; s = "ABD##E#F##C##"; BinaryTree&lt;char> a; //数据类型为int，0表示没有 //int s[] = { 1,2,3,0,0,4,0,5,0,0,6,0,0 }; //BinaryTree&lt;int> a; a.create_tree(s.c_str(), s.size()); //a.create_tree(s, 13); cout &lt;&lt; "前序遍历：" &lt;&lt; endl; a.pre_order(); cout &lt;&lt; "中序遍历：" &lt;&lt; endl; a.in_order(); cout &lt;&lt; "后序遍历：" &lt;&lt; endl; a.post_order(); cout &lt;&lt; "层序遍历：" &lt;&lt; endl; a.level_order(); cout &lt;&lt; "树高：" &lt;&lt; endl; cout &lt;&lt; a.get_height() &lt;&lt; endl; return 0; } 一些比较常规的算法题 大部分是学校数据结构课做的。挑一些比较有意思的放出来，会尽量注释详细。
二叉树结点的最大距离 题目描述 二叉树两个结点的距离是一个结点经过双亲结点，祖先结点等中间结点到达另一个结点经过的分支数。二叉树结点的最大距离是所有结点间距离的最大值。例如，下图所示二叉树结点最大距离是3，C和D的距离。 二叉树用先序遍历顺序创建，#表示空树。计算二叉树结点最大距离和最大距离的两个结点(假设二叉树中取最大距离的两个结点唯一）。
输入 测试次数T 第2行之后的T行，每行为一棵二叉树先序遍历结果（#表示空树）
输出 对每棵二叉树，输出树的结点最大距离和最大距离的结点，输出格式见样例。
样例输入 3 A## ABC##EF#G###D## ABEH###F#K### 样例输出 0: 5:G D 4:H K 题目解析 对每个节点，子树的最长路径有两种可能，一种是从根节点到叶子结点（左），一种是从叶子结点到另一个叶子节点（右），而leaf to leaf最大距离 = 根to左侧最深 + 根to右侧最深。所以只用递归采用后序遍历，对每个节点计算最长的根叶子距离和叶子到叶子距离，取较大的那个作为max distance返回。这样到根节点时，就能得到最大的节点路径。
AC代码 #include &lt;iostream>#include &lt;string.h>#include &lt;queue>using namespace std; template &lt;typename T> class Node { public: T data; Node* left; //左子节点 Node* right; //右子节点 }; template &lt;typename T> class BinaryTree { private: Node&lt;T>* root; //根节点 Node&lt;T>* create_tree(const T* s, int&amp; pos, int s_len); int post_order(Node&lt;T>* n, int* record); public: BinaryTree(); void create_tree(const T* s, int s_len); void post_order(); //后序遍历 void max_distance(); }; template &lt;typename T> BinaryTree&lt;T>::BinaryTree() { root = NULL; height = -1; leaves = 0; } template &lt;typename T> Node&lt;T>* BinaryTree&lt;T>::create_tree(const T* s, int&amp; pos, int s_len) { ++pos; Node&lt;T>* n; if (pos >= s_len) return NULL; else { if (s[pos] == '#') //该位置没有节点 n = NULL; else { n = new Node&lt;T>; n->data = s[pos]; n->left = create_tree(s, pos, s_len); n->right = create_tree(s, pos, s_len); } return n; } } template &lt;typename T> void BinaryTree&lt;T>::create_tree(const T* s, int s_len) { int pos = -1; root = create_tree(s, pos, s_len); } template &lt;typename T> void BinaryTree&lt;T>::pre_order() { pre_order(root); cout &lt;&lt; leaves &lt;&lt; endl; } template &lt;typename T> void BinaryTree&lt;T>::max_distance() { int* record = new int; int num = post_order(root, record); if (num) cout &lt;&lt; num &lt;&lt; ":" &lt;&lt; root->l_deepest &lt;&lt; " " &lt;&lt; root->r_deepest &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; ":" &lt;&lt; endl; delete record; } //最大距离可能为 //1.node左子树上最大距离 //2.node右字数上最大距离 //3.node左子树深度+右子树深度 template &lt;typename T> int BinaryTree&lt;T>::post_order(Node&lt;T>* n, int* record) { if (n == NULL) { *record = 0; //存深度 return 0; } int l_max = post_order(n->left, record); //左子树上最大距离 int l_depth = *record; //左子树深度 int r_max = post_order(n->right, record); //右子树上最大距离 int r_depth = *record; //右子树深度 int cur_node_depth = l_depth + r_depth; //左子树深度+右子树深度 *record = max&lt;int>(l_depth, r_depth) + 1; //当前节点深度 return max&lt;int>(max&lt;int>(l_max, r_max), cur_node_depth); //返回当前节点的最大距离 } //也就是当前节点作为根节点，其子节点的最大距离 int main() { int t; cin >> t; while (t--) { char* s = new char[100]; cin >> s; BinaryTree&lt;char> bt; bt.create_tree(s, strlen(s)); bt.max_distance(); delete[] s; } return 0; } 求根到叶子结点路径上权值的和 题目描述 给定一颗二叉树的逻辑结构（先序遍历的结果，空树用字符‘0’表示，例如AB0C00D00），建立该二叉树的二叉链式存储结构 二叉树的每个结点都有一个权值，从根结点到每个叶子结点将形成一条路径，每条路径的权值等于路径上所有结点的权值和。编程求出二叉树的最大路径权值。如下图所示，共有4个叶子即有4条路径
路径1权值=5 + 4 + 11 + 7 = 27 路径2权值=5 + 4 + 11 + 2 = 22 路径3权值=5 + 8 + 13 = 26 路径4权值=5 + 8 + 4 + 1 = 18 可计算出最大路径权值是27
该树输入的先序遍历结果为ABCD00E000FG00H0I00，各结点权值为： A-5，B-4，C-11，D-7，E-2，F-8，G-13，H-4，I-1
输入 第一行输入一个整数t，表示有t个测试数据 第二行输入一棵二叉树的先序遍历，每个结点用字母表示 第三行先输入n表示二叉树的结点数量，然后输入每个结点的权值，权值顺序与前面结点输入顺序对应 以此类推输入下一棵二叉树
输出 每行输出每棵二叉树的最大路径权值，如果最大路径权值有重复，只输出1个
样例输入 2 AB0C00D00 4 5 3 2 6 ABCD00E000FG00H0I00 9 5 4 11 7 2 8 13 4 1 样例输出 11 27 题目解析 先序建树，然后后序遍历节点，记录访问过的节点的数据，访问根节点时比较取权值较大的子树。比如图中7>2，访问11时就取7。递归到最后得到的就是权值最大的数据。
其实可以优化，边建树边计算数据，效率会更高，但是做的时候没想到，就不写了。
AC代码 #include &lt;iostream>using namespace std; int cnt; int* dt; template &lt;typename T> class Node { public: T data; Node* left; //左子节点 Node* right; //右子节点 }; template &lt;typename T> class BinaryTree { private: Node&lt;T>* root; //根节点 int height; //高度 Node&lt;T>* create_tree(const char* s, int&amp; pos, int s_len); int post_order(Node&lt;T>* n); public: BinaryTree(); void create_tree(const char* s, int s_len); void post_order(); //后序遍历 }; template &lt;typename T> BinaryTree&lt;T>::BinaryTree() { root = NULL; height = -1; } template &lt;typename T> Node&lt;T>* BinaryTree&lt;T>::create_tree(const char* s, int&amp; pos, int s_len) { ++pos; Node&lt;T>* n; if (pos >= s_len) return NULL; else { if (s[pos] == '0') //该位置没有节点 n = NULL; else { n = new Node&lt;T>; n->data = dt[cnt]; cnt++; n->left = create_tree(s, pos, s_len); n->right = create_tree(s, pos, s_len); } return n; } } template &lt;typename T> void BinaryTree&lt;T>::create_tree(const char* s, int s_len) { int pos = -1; root = create_tree(s, pos, s_len); } template &lt;typename T> void BinaryTree&lt;T>::post_order() { cout &lt;&lt; post_order(root) &lt;&lt; endl; } template &lt;typename T> int BinaryTree&lt;T>::post_order(Node&lt;T>* n) { if (n == NULL) return 0; int max1, max2; max1 = post_order(n->left); max2 = post_order(n->right); return max1 > max2 ? max1 + n->data : max2 + n->data; //返回权值较大的子树 } int main() { int t; cin >> t; while (t--) { string s; cin >> s; //s存的节点名称 int num; cin >> num; dt = new int[num]; for (int i = 0; i &lt; num; i++) cin >> dt[i]; //存节点的数据 BinaryTree &lt;int> btree; btree.create_tree(s.c_str(), s.size()); btree.post_order(); delete[] dt; } return 0; } 后序遍历的非递归算法 因为递归的实现是通过栈，递归到下一层的时候，把当前的函数压栈。所以如果有一棵树特别长，就会发生栈溢出。所有的递归，都是可以通过非递归的方式实现的，这就是这道算法题的背景知识&hellip;
输入 第一行输入一个整数t，表示有t个测试数据 第二行起输入二叉树先序遍历的结果，空树用字符‘0’表示，输入t行
输出 逐行输出每个二叉树的后序遍历结果
样例输入 3 AB0C00D00 ABC00D00EF000 ABCD0000E0F00 样例输出 CBDA CDBFEA DCBFEA 直接上代码 #include &lt;iostream>#include &lt;string>#include &lt;stack>using namespace std; template &lt;typename T> class Node { public: T data; Node* left; //左子节点 Node* right; //右子节点 }; template &lt;typename T> class BinaryTree { private: Node&lt;T>* root; //根节点 Node&lt;T>* create_tree(const T* s, int&amp; pos, int s_len); void post_order(Node&lt;T>* n); public: BinaryTree(); void create_tree(const T* s, int s_len); void post_order(); //后序遍历 }; template &lt;typename T> BinaryTree&lt;T>::BinaryTree() { root = NULL; } template &lt;typename T> Node&lt;T>* BinaryTree&lt;T>::create_tree(const T* s, int&amp; pos, int s_len) { ++pos; Node&lt;T>* n; if (pos >= s_len) return NULL; else { if (s[pos] == '0') //该位置没有节点 n = NULL; else { n = new Node&lt;T>; n->data = s[pos]; n->left = create_tree(s, pos, s_len); n->right = create_tree(s, pos, s_len); } return n; } } template &lt;typename T> void BinaryTree&lt;T>::create_tree(const T* s, int s_len) { int pos = -1; root = create_tree(s, pos, s_len); } template &lt;typename T> void BinaryTree&lt;T>::post_order() { post_order(root); cout &lt;&lt; endl; } template &lt;typename T> void BinaryTree&lt;T>::post_order(Node&lt;T>* n) { Node&lt;T>* p; stack&lt;Node&lt;T>*> s1; stack&lt;int> s2; int tag; p = n; do { if (p != NULL) { tag = 0; s1.push(p); s2.push(tag); p = p->left; } if (s1.empty()) break; if (p == NULL) { tag = s2.top(); if (tag == 0) { s2.pop(); s2.push(1); p = s1.top()->right; } if (tag == 1) { p = s1.top(); cout &lt;&lt; p->data; s1.pop(); s2.pop(); p = NULL; } } } while (!s1.empty()); } int main() { int t; cin >> t; while (t--) { string s; cin >> s; BinaryTree&lt;char> a; a.create_tree(s.c_str(), s.size()); a.post_order(); } return 0; } 用中后序输出的数据建树 题目描述 按中序遍历和后序遍历给出一棵二叉树，求这棵二叉树中叶子节点权值的最小值。 输入保证叶子节点的权值各不相同。
输入 第一行输入一个整数t，表示有t组测试数据。 对于每组测试数据，首先输入一个整数N (1 &lt;= N &lt;= 10000)，代表二叉树有N个节点，接下来的一行输入这棵二叉树中序遍历的结果，最后一行输入这棵二叉树后序遍历的结果。
输出 对于每组测试数据，输出一个整数，代表二叉树中叶子节点权值最小值。
样例输入 3 7 3 2 1 4 5 7 6 3 1 2 5 6 7 4 8 7 8 11 3 5 16 12 18 8 3 11 7 16 18 12 5 1 255 255 样例输出 1 3 255 题目解析 因为后续输出的最后一个一定是根节点，就可以通过后序的数据在中序的数据中找到根节点，然后中序的数据中，根节点左边一定是左子树，右边一定是右子树。中序是先输出左子树，后序也是先输出左子树，找到后序的左子树部分的最后一个节点，就是左子树的根节点。详细的看代码。
AC代码 #include &lt;iostream>using namespace std; class Node { public: int data; Node* left, * right; }; class BiTree { private: Node* root; int num; // num of nodes int* post; int* in; int min; Node* CreateTree(int* post, int* in, int n); void preorder(Node* p); void getMin(Node* p); public: BiTree(); ~BiTree(); void CreateTree(); void preorder(); int getMin(); }; BiTree::BiTree() { cin >> num; post = new int[num]; in = new int[num]; for (int i = 0; i &lt; num; i++) cin >> in[i]; for (int i = 0; i &lt; num; i++) cin >> post[i]; root = CreateTree(in, post, num - 1); } BiTree::~BiTree() { //理论上是要删节点的 delete[] post; delete[] in; } Node* BiTree::CreateTree(int* in, int* post, int n) { //n是新建节点在post的位置 if (n == -1) return nullptr; int i = 0; for (; in[i] != post[n]; i++); //用i记录在in串的位置 Node* node = new Node; node->data = post[n]; node->left = CreateTree(in, post, i - 1); //in指针起始位置移当前结点的下一个，剩下的串为右子树节点 //post指针【起始位置】移到后移i位，i为左子树的结点数，剩下的串为右子树节点 //post[n-i-1]是下一个递归的post[n] node->right = CreateTree(in + i + 1, post + i, n - i - 1); return node; } void BiTree::getMin(Node* p) { if (p->left == nullptr &amp;&amp; p->right == nullptr) { if (p->data &lt; min) min = p->data; return; } if (p->left != nullptr) getMin(p->left); if (p->right != nullptr) getMin(p->right); } int BiTree::getMin() { //其实也是在建树的时候就可以计算数据，时间会少一半左右 //但是建树的代码比较复杂，所以就不让它更复杂了吧 //这个就是简单的前序遍历找权值最小的叶子结点 min = root->data; getMin(root); return min; } int main() { int t; cin >> t; while (t--) { BiTree mytree; cout &lt;&lt; mytree.getMin() &lt;&lt; endl; } } 二叉树的中后序遍历及操作 题目描述 按中序遍历和后序遍历给出一棵二叉树，现在有如下操作：
UPDATE A B，将中序遍历中A位置（从1开始编号的下标）对应的在二叉树中的节点的权值改为B QUERY，询问树上所有节点的权值，以及从根节点到该节点的路径权值之和 STOP，停止操作，STOP操作一定出现在最后 中序遍历和后序遍历的输入保证叶子节点的权值各不相同。但是，之后如果存在UPDATE操作，则UPDATE操作可能会使得两个或两个以上的叶子节点的权值相同。 输入 输入t组测试数据； 接下来输入k组测试数据，对于每组测试数据： 第一行输入这棵二叉树的结点数 第二行输入这棵二叉树中序遍历的结果
第三行输入这棵二叉树后序遍历的结果 接下来每一行输入一种操作，直到输入STOP操作时结束本组测试数据的输入。其中，QUERY操作次数 &lt;= 2，总操作数 &lt;= 104
输出 对于每组测试数据： 对于QUERY操作，按中序遍历输出节点的权值，以及从根节点到该节点路径权值之和。这里，我们认为根节点到其本身的路径权值之和为根节点的权值
题目解析 因为update操作可能会导致权值相同，所以用权值查找节点可能找的不准，要用序号找，注意到这一点就应该没啥问题了。然后每查询一次就遍历一次其实效率会比较低，可以用一个指针数组，存序号对应的节点，然后update的时候从数组访问节点。那这么一看好像连建树都不用了&hellip;不过我做的时候没想到，用的update一次就遍历一次的方法QwQ
样例输入 3 7 3 2 1 4 5 7 6 3 1 2 5 6 7 4 UPDATE 5 99 UPDATE 6 123 UPDATE 1 37 QUERY UPDATE 1 36 QUERY STOP 8 7 8 11 3 5 16 12 18 8 3 11 7 16 18 12 5 QUERY STOP 1 255 255 STOP 样例输出 37 43 2 6 1 7 4 4 99 226 123 127 6 133 36 42 2 6 1 7 4 4 99 226 123 127 6 133 7 12 8 31 11 23 3 26 5 5 16 33 12 17 18 35 AC代码 #include &lt;iostream>using namespace std; class Node { public: int data; Node* left, * right; }; class BiTree { private: Node* root; int num; // num of nodes int* post; int* in; int a; int b; Node* CreateTree(int* post, int* in, int n); void inOrder(Node* n, int&amp; cnt); void query(Node* n, int cnt); public: BiTree(); ~BiTree(); void update(); void query(); }; BiTree::BiTree() { cin >> num; post = new int[num]; in = new int[num]; for (int i = 0; i &lt; num; i++) cin >> in[i]; for (int i = 0; i &lt; num; i++) cin >> post[i]; root = CreateTree(in, post, num - 1); } BiTree::~BiTree() { delete[] post; delete[] in; } Node* BiTree::CreateTree(int* in, int* post, int n) { if (n == -1) return nullptr; int i = 0; for (; in[i] != post[n]; i++); Node* node = new Node; node->data = post[n]; node->left = CreateTree(in, post, i - 1); node->right = CreateTree(in + i + 1, post + i, n - i - 1); return node; } void BiTree::update() { cin >> a >> b; int cnt = 0; inOrder(root, cnt); } void BiTree::inOrder(Node* n, int&amp; cnt) { if (n == nullptr) return; inOrder(n->left, cnt); cnt++; if (cnt == a) n->data = b; else inOrder(n->right, cnt); return; } void BiTree::query() { query(root, 0); } void BiTree::query(Node* n, int cnt) { if (n == nullptr) return; cnt += n->data; query(n->left, cnt); cout &lt;&lt; n->data &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; endl; query(n->right, cnt); return; } int main() { int t; cin >> t; while (t--) { BiTree mytree; string cmd; while (cin >> cmd) { if (cmd[0] == 'U') mytree.update(); if (cmd[0] == 'Q') mytree.query(); if (cmd[0] == 'S') break; } cout &lt;&lt; endl; } } Falling Leaves （DFS求每一列权值的和） 题目描述 按先序遍历给出一棵二叉树，每个结点都有一个水平位置：左子结点在它左边一个单位，右子结点在右边1个单位。从左向右输出每个水平位置的所有节点的权值之和。 例如：以下二叉树有三个水平位置，从左至右的输出是7,11,3。
输入 测试数据有多组，每组测试数据输入按先序遍历输入一棵二叉树，其中-1代表空节点（一棵树的节点数量不超过 103） 当输入的二叉树是一棵空树时，结束输入。
输出 对于每组测试数据，首先输出一行"Case x:"，其中x代表这是第x个测试数据的输出，然后从左到右输出每个水平位置所有节点的权值之和
样例输入 5 7 -1 6 -1 -1 3 -1 -1 8 2 9 -1 -1 6 5 -1 -1 12 -1 -1 3 7 -1 -1 -1 -1 样例输出 Case 1: 7 11 3 Case 2: 9 7 21 15 题目解析 这个题目说的不是人话。用人话说是，输出每一竖列节点的权值和。其实这道题不用建树，大概判断一下最多可能有多少列，然后开个数组存每一竖列的权值和。因为先序的数据是根、左、右，所以只用写个巧妙的递归就能计算出结果。
AC代码 #include &lt;iostream>#include &lt;string.h>using namespace std; const int maxn = 200; int sum[maxn]; void build(int p) { int v; cin >> v; if (v == -1) return; //空树返回 sum[p] += v; build(p - 1); build(p + 1); } bool init() { int v; cin >> v; if (v == -1) return false; memset(sum, 0, sizeof(sum)); int pos = maxn / 2; //根节点位置 sum[pos] = v; build(pos - 1); //左子树 build(pos + 1); //右子树 } int main() { int _case = 0; while (init()) { int p = 0; while (sum[p] == 0) p++; cout &lt;&lt; "Case " &lt;&lt; ++_case &lt;&lt; ":\n" &lt;&lt; sum[p++]; while (sum[p] != 0) cout &lt;&lt; ' ' &lt;&lt; sum[p++]; cout &lt;&lt; "\n\n"; } return 0; }</content></entry><entry><title>该关注的不止是处长体验外卖员生活</title><url>https://yinan-hong.github.io/post/workersday/</url><categories><category>键政</category></categories><tags><tag>劳资矛盾</tag><tag>996</tag><tag>社会问题</tag></tags><content type="html"> 五一国际劳动节  国际劳动节又称“五一国际劳动节”、“国际示威游行日”（International Workers' Day或者May Day），是世界上80多个国家的全国性节日。定在每年的五月一日。它是全世界劳动人民共同拥有的节日。
 19世纪，随着第二次工业革命，资本主义发展到帝国主义阶段，为了刺激经济高速发展，压榨更多的剩余价值，资本家采取增加劳动时间和劳动强度的方法，来剥削工人。在美国，工人每天要劳动14至16小时，有的甚至长达18小时，但工资却很低。
 1886年5月1日，以美国芝加哥为中心，举行了约35万人的大规模罢工和示威游行，争取八小时工作制。
讲个网约车行业的故事  最近打滴滴，遇到的司机都喜欢聊政治，我晕车不敢玩手机，就只能唯唯诺诺跟司机侃大山…
 昨晚遇到的司机师傅，是因为做生意不成功，只好关掉自己的仓库，从事网约车行业。不难想象，在2020年疫情的冲击下，很多失业人员会选择从事网约车、外卖员、快递员之类的行业。这些行业的共同特点是，不需要有什么专业知识储备，不需要有经验，基本是靠体力劳动多劳多得。
平台没有给司机足够的保障  我在高一还是高二的时候，为了完成社会实践课的作业，还做过一次出租车行业的调查，对网约车行业有些许了解，于是问了司机师傅一些我关注的问题。网约车平台限制司机每天的载客时间（空载时间不算），大概是不能超过十小时。人和车绑定，所以不能像出租车那样两个人轮班倒。**如果司机一个月30天都不休息，每天勤快点跑十多个小时，那一个月的收入可以有10k以上。**不过司机师傅感觉最近接到的单越来越少，可能是因为有太多人来从事这个行业，人多了分到的单就少了。这种情况在外卖员之类的类似的行业也可能会有。
 司机师傅还讲了个有意思的事情。他载过一些十八九岁的年轻乘客，都是去一些工厂打工的，这些乘客在快下车前总是会（假装）打电话或者聊微信，下车时就会说打完电话之后再付款，然而这些人之后一般都不会付款，这部分损失是由司机自己承担的。我问，遇到这样的行为，平台会做什么吗？得到的答案令我很无语。平台在一天内会以短信的形式提醒乘客付款，如果乘客还是没有付款的话，平台会给司机一个虚拟手机号，司机自行联系乘客。但如果乘客还是没付款的话，三五天后那个虚拟手机号就失效了，司机也只能自己承担损失了。
网约车体系，某滴涉及所有类型，其他公司则专注细分领域
 我自己用过的一些平台，比如某团啊，是要在上车前先付款，然后到了目的地之后多退少补的，这样对大家都有保障。于是我接着问了，有没有什么行业工会啊，或者有没有什么保护自身权利的方法啊之类的。答案自然是都没有的。
北京人社局处长体验外卖员职业  前几天这个视频还是比较火的，相信不少人都看过。大致内容是北京人社局一个副处长，为了制定更符合新业态工作人员（外卖员、网约车司机等）需求的政策，亲自注册了一个美团账号，跟着一个真的外卖员送了一天外卖。里面有几个值得注意的点啊。
 首先这个纪录片不是那种主旋律的，一定程度上真实地反映了外卖员的工作和生活。
 副处长送了几单之后，累的不行，提出需不需要平台提供一个送几单就休息一下的机制。外卖小哥却说不希望限制最高或最低工作时长。
 后来副处长问了小哥的梦想，小哥回答说想成立一个骑手之家。虽然我觉得这有一定的剧本嫌疑，不过我在网上看到有些评论说这是想要一个类似工会的组织。
 视频里还提到，平台其实和骑手之间存在一定的管理关系，而视频后面又说了骑手如果意外受伤后没有医疗保障的问题。
 本来是想讲讲工会的，但是怕篇幅太长了没人看，有机会单独写一篇文章吧。
 底层劳动人民缺少维护自身利益的意识，这就让资本有了剥削无产阶级的机会。而实际上工会，特别是中国的工会并没有很大的存在感，也没有很好地起到了维护工人利益的作用。你看码农工会可不就在那里，然而码农该996的996，该251的251。所以最重要的是，无产阶级需要有维护自身利益的意识，要有团结起来维护阶级利益的意识。
每个行业都有劳资矛盾  其实所有行业，不只是外卖员和网约车司机，劳动者想要获得更高的劳动报酬，其实只能通过增加劳动时间和劳动强度的方式。996其实也是同样的道理。现状就是，老板提供了资本，工人提供了劳动力，老板想要用更少的代价换来更多的收益（剩余价值），工人只能通过增加劳动时间和劳动强度来获得更高的报酬。如果通过监管，限制劳动的话，其实牺牲的是两方的利益，因为就是有人愿意用高强度、长时间工作来换取更高的报酬。
 像网约车行业这样，疲劳驾驶有可能危害乘客的生命安全，所以有必要存在限制劳动的制度。而外卖员没有限制劳动的制度，外卖员意外受伤却没有任何的保障，外卖员不但要承担自己的医疗，还损失了工作时间。又因为上一段提到的，监管其实不应该限制劳动。其他行业同理，比如程序员，996能赚钱，但是过劳死的风险和代价需要自己承担。
互联网公司没有明文要求996,但到了下午六七点根本没人走，领导也十点多才走，你敢早走吗？
劳资矛盾的现象规律  当劳动者多了之后，劳动力的价值就降低。当人口红利过去，劳动力价值提高之后，资本家不愿意给你更多的工资怎么办呢？这时候就出现了内卷、奋斗者协议之类的东西。内卷说白了就是韭菜在恶性竞争，资本家正好趁机压低韭菜价格，至于奋斗者协议那就是个傻韭菜才会签的东西。 政策方面，比如五一调休这波骚操作，其实也是各方矛盾综合下的结果。五天假期减去调休的两天就还剩三天，三天减去原本两天的周末，调来调去实际上只放了一天。假期延长提高了出行欲望，带来了更多的经济效益，同时又没有损失调休两天的社会生产。总之，劳动者，资本和政府之间存在着诸多矛盾，相互制约之下形成了现在的社会经济体系。
无产阶级应该抗争  资本家出钱，劳动者出力，赚的钱是资本家分到了大多数，这样显然不是实现共同富裕的方式。但提高税收，提高最低工资标准，禁止高强度工作这样的制度也不是拍拍脑袋说行就行的。
 北欧的高社会福利国家（真正的社会主义国家狗头）能通过对有钱人高额征税来实现高社会福利，这是基于人少和产业结构优。随着我国人口自然增长率的下降，劳动力价值的提升我觉得是自然而然的事情，内卷只是一时的。想要人人都过的好，还是要靠更优的产业结构和更优的分配制度。喊着“劳动人民最光荣这样的口号”来骗取劳动力的日子已经过去，无产阶级同志们想要过上好日子，需要团结起来，为自己阶级的利益抗争。
 最后祝所有劳动人民劳动节快乐。
 </content></entry><entry><title>我就是太理想主义了</title><url>https://yinan-hong.github.io/post/dreaminglism/</url><categories><category>生活杂谈</category></categories><tags><tag>生活杂谈</tag></tags><content type="html"> 题外话  好久没更新了，因为我懒，或者我忙。其实这段时间有挺多话说的，大概从过年那段时间开始，关于人人影视被封和国内的盗版文化，后来两会期间的各种迷惑议题，教育部明文禁手机和深中的反应，再到最近的棉花。热度都过了不写了…
 为了今年的flag不倒，我还是勉为其难更新一下公众号，虽然我的电钢琴已经沦为吉他谱架了&hellip;
我就是太理想主义了  我总是期望事情往好的方向发展，虽然我会为最坏的情况做准备，但还是会期待最好的情况的出现。比如做官微采访的时候，总是会期待能有很好的素材，但我也会为交上来的素材全都不能用的情况做准备。比如不去上课的时候会期待不点名，但我也做好了被扣考勤分的准备…
 虽然事情总是会turn out as bad as it can be&hellip;
 我希望我和朋友的关系是非常理想化的，但身边的人恕我直言都太现实了，感觉没有人能get到我很理想主义的点，所以感觉在现在呆的地方没有什么关系很好的朋友。反正我这辈子就是在不断地getting out of a shitty place and getting in another, 已经在期待下一个shit hole了。
最近心情不错  我终于能说我放下了一些去年发生的不好的事，然后正在尝试放下更多更早发生的不好的事。
 （quote孙燕姿）我不难过，这不算什么，开始懂了，快乐是选择&hellip;两三年来，能让我快乐的事只有睡觉，终于现在吃东西和看剧又能让我感到快乐了……
关于学习  虽然说学校不知道说了多少以就业为导向，但怎么都不是以offer为导向教学。毕竟不是每个高中都有生涯教育之类的，感觉身边还是有很多人不知道该干嘛的。我还是管好自己，以offer为导向自学吧…
 但是不得不吐槽，java基础语法能讲三四个星期，数据结构讲顺序表、链表讲了三四个星期&hellip;上学期的操作系统跟没讲操作系统一样，下学期要怎么边学计网边找实习？逗我8&hellip;拿一学期出去实习作为必修课程真的有必要吗？
 顺便，上学期末告诉我上机题目课上做完给满分，课下做完只给一半分我实在无语，虽然我做完的也不少。有些朋友，出于任何目的，为了装逼也好，真就为了成绩也好，课前找别的班的要题目，然后在课上敲完的，恕我直言都是垃圾。期末考了a+还有脸晒出来的我真是佩服的五体投地&hellip;这年头脸皮比我厚的人不多了。
 Anyway，现在学的东西谈不上喜欢…要不是为了当码农工资高大概率不会来…
关于人际  周围的各位大哥最近都在忙赛车工作室忙的要死，没人陪我玩。我还是很不想social扩充交际圈什么的，太累人了。不愿为了social付出时间和精力，总感觉有点亏，不如多睡一会。
 感觉我之前立的人设让大家多多少少有点误解，给我带来了一些困扰。想澄清一下我不是富二代，住在深圳的人家里不一定有钱 =.= 我虽然还没穷到吃不起饭，但也过不上小资生活。我家里没有任何物质or anything留给我（不是不给是真没有），甚至连个像样的家(mental and physical)都没。我只能靠自己实现阶级跨越，so，leave me alone 别烦我
 前段时间有人跟我说不敢跟我接近，因为怕我对他做出我曾经做过最恶劣的事。Well，首先要是你没对我做出什么恶劣的事，为什么要assume我会对你做什么呢…然后，最近放假二刷复联四，就很希望能有这么个惺惺相惜的朋友之类的whatever
 可能就，太理想主义了。这么美好的关系怎么可能真的存在嘛，要有也不会发生在我身上吧。反正，谁不喜欢我就fuck off吧，越来越觉得just be myself and let其他事顺其自然就好了。最近心态很好，没什么能影响我的好心情…
关于漫威  By the way，寡姐电影又双叒叕改档了QwQ，五一没盼头了，盼暑假吧。还有毒液2啊啊啊啊。感慨一下没有漫威电影的2020，世界赶快好起来QwQ求求了。
 最近看剧没什么讨论社群，于是第一次下了某瓣，结果发现里面就是一堆喷子嘛&hellip;旺达幻视有红女巫的颜撑着，路人评价还不错，到猎鹰冬兵就各种评价水时长水剧情&hellip;我是真的无语。比方说看小说也没有从最后一部开始看，看不懂世界观看不懂梗然后差评的吧&hellip;个人更喜欢猎冬多过幻红，幻红更多的是为后面电影的铺垫，猎冬不仅铺垫还更完善了漫威宇宙世界观，不细说了。
Ending  噢对了，最近感觉有点胖，又开始锻炼了一下两下三下…但是我真的瘫了太久了，真的不会中考那一阵子是我这辈子的体能巅峰了吧不会吧不会吧不会吧&hellip;
 最后祝大家开心，希望世界和平love &amp; peace
 Over
 </content></entry><entry><title>洪逸楠的2020个人年度总结</title><url>https://yinan-hong.github.io/post/2020yearly/</url><categories><category>生活杂谈</category></categories><tags><tag>feelings</tag></tags><content type="html">  2020年唯一的收获就是兔楠又回来了，嗯，就是内个帅气阳光开朗乐观，想在自己的票圈里成为网红的小伙汁。
 这辈子第一次写年度总结，前几天在构思的时候想的都是怎么吐槽我这一年来经历的种种不快，但这样多没意思呀，还是认认真真总结一下这一年的收获、成长、错误和遗憾吧。（写完回来补了句：还是写得很随便，记录了一下心情，心路历程什么的
 从高二开始我的情绪就一直在走下坡路，在高考前后达到最低谷。原因浓缩成两个字——family drama（家庭抓马）。要讲我的家庭和成长经历，两天都讲不完，还记得五月和祥乐在八楼天台从九点十点聊到一两点还意犹未尽。总之，我能回到原来兔楠的状态实属不易。
2020.1.1  这天在军训，深中游园会去不成了，不嗨森。放寒假了，只约了cc、pz出去喝了个酒吃了个烧烤。本想除夕去二姑家陪我奶奶她老人家过个年，呆个一星期就回学校，都想好在假期要怎么弯道超车了。然而这该死的疫情把我困在了二姑家两个月。
 只能说家里人在让我失望这件事情上从未让我失望。临近网课开课，我撂下一句你这辈子再也别想见到我，拉上行李回了大姑家。
2020.3.2  网课第一天，第一节是高数课。虽然大一上学期高数考了A，但是在学期末讲的为下学期开头的内容就没听过，网课啥也没听，然后第一次也是我最后一次出席高数网课。因为下定了决心要转专业，所以像机械原理啊，大物啊这些课我是一点听的兴趣都没有。状态确实不好，每天就是睡大觉。好在有好好学C语言，或许是有天赋（？），现在看来基础还算够用。
 盘点一下疫情期间刷的美剧，911（紧急救援）系列4季，是真的好看，虽然各种美国zz正确，但是真的好看；upload（上载新生），新剧，像是黑镜的哪一集，是讲人快死时把人的意识上传到server继续云生活的，有点意思值得等第二季；homeland（国土安全）八季，已完结神剧，开始追时在播出最后一季，看到最后一季正好全部播完，爽！当之无愧的神剧！这辈子看过最好看的剧情片，是以CIA在围绕中东局势的各种行动之类的展开的剧情，好看的不得了，里面主角死了就是死了，一点光环都没有的那种，这才是真正的爱国主义吧，写在脸上刻在骨子里的爱国。
 Anyways&hellip;.我网课时期就浑浑噩噩地这么过去了。哦对了，开学前和老同学们聚的几次都很开心，想大家了~
 如果重新来过的话，我估计这段时间我还是会打不起精神来，不是我没毅力，是真的累，心累。
2020.5.16  啦啦啦没人送我，前一天收拾好行李，第二天早早起来戴上口罩就去北站→坪山站→学校了。一个以前的朋友出了点事，那时我还会为他担心，他晚了一个星期回学校。到这个时候，我还是整天一副比较颓的状态，想平平淡淡过完四年就好，心态就像高三和Donna说的，我只想一切都稳定下来，虽然听起来很老年，但我真的不想再有什么起伏了。
 虽然大一上学期只是稍微学了下习，但也随随便便考到了专业第二，但大一下是真的没学，那时候身边的人各种虚伪我。我本来就没学就挺慌的，还整天有人在耳边念叨不用学都能考A+辣，真的深中虚伪的ptsd。这次我发了个小脾气，被祥乐拉去八楼谈心，然后这学期的声乐课让我和林生成为了好盆友。也让我发现了，如果我愿意去交朋友，还是有很多人愿意跟我玩的。
 我这么大方的人当然不会为一些小事生很久的气，很快大家又恢复了友善。最后的友善。
 对了，6.1那天老朋友来村探望，开心！
2020.7.9  这天考C语言，这天我生日，收到了大家的礼物，即使第二天考高数，我还是很开心。暑假到了，我不想回姑姑家，因为宿舍有大屏幕很爽…疫情让我半年见不到我的大屏幕呜呜呜。但学校一定要赶人走。临近离校期限，招生办要招勤工俭学的学生，会做推文会ps、pr又有颜值加成可以带学生家长参观校园的我果然被选上了。于是和以前的一个朋友在学校呆了一个暑假，在招生办打了一暑假暑假工。
 除了cc生日那天下午进了趟城，晚上回了学校，下一次进城就要到国庆了。假期借了林生的吉他，于是过着白天去招生办打工，晚上回来练吉他的充实生活。两个月的时间练到能勉勉强强自弹自唱啦！开心！放假前期还骑车去了趟海边，放假后期还去了趟大梅沙游泳，都是跟以前的一个朋友，开心。暑假还开始尝试用ipad画画，买来这板子终于生产力了一下。至少会自己画表情包了。
2020.9.1  如愿顺利转了专业，感觉一切又好了起来。远离家人大半年，知道了一个人有多清净。踏出舒适圈的第一步是决定写公众号，第二步是当了个朋导。朋导就是类似于深中的学长团，小大一刚来学校的时候带带他们。朋导的竞选很仓促啊，前一天发通知，过几天就演讲竞选了，然后再过几天大一就开学了&hellip;好像在新生开学前几天发了本号第一篇推文。
 就简单讲了下高中社团经历，对朋辈的理解，对学长团的理解，于是很顺利地被班主任相中捞去当了朋导。据说我当时还挺抢手的&hellip;傲娇脸
2020.10.1  这学期实在是太忙了，太！忙！了！很显然刚开学，我在忙新生的事我在忙学习的事我还在忙做官微推文，明明我事情最多，谁也别跟我比。被影响了休息，我逐渐暴躁。我有充足的理由发脾气，我确实没有留余地，他们自然做出了不留余地的选择。经历了什么不是当事人是一定不会了解到全部，一定做不到感同身受的。所以谁也别judge谁。就连我觉得最了解这件事的局外人都不能理解我的感受。如果当时大家都忍一时风平浪静，退一步越想越气的话现在可就是另一种剧情了。
 我做的最错的地方大概是发脾气没发在该被发的人身上。虽然道过歉了，但哆啦A梦还是挺无辜的，希望他一切都好。As for 我讨厌的人，如果过的好的话低调一点不要让我知道，如果过得不好的话说给我听让我开心一下。
 以为删光了痕迹就不会再记起了，然而&hellip;想必他们也一样吧
 心态再度爆炸，你信不信我也是会难过的？他们搬走那天晚上我把宿舍收拾得很干净，不想睡觉，即使第二天要考作文比赛和阅读比赛。虽然基本相当于没睡，但第二天随随便便考完还是进了复赛&hellip;于是后面的日子就在每天满课满课满课，周末总是有大大小小的比赛或开会。能休息或安安静静自习的大块时间越来越少，烦人的专业水课越来越多。（说的就是你RFID、传感器，统统去死吧
2020.11.11  因为之前申到了奖学金，加上宿舍略显空旷，于是买来了一个新朋友。心态逐渐平复，该干嘛干嘛。发现帆帆会弹钢琴，技大杰伦唱歌好听，人又帅，多了个好朋友，开心。后面除了天天满课，一堆作业，推文，各种校级小比赛就没啥特别的事情了，还是没有时间睡觉。双十二真·裸考了个四级，一套模拟题都没做过&hellip;考试前一天才知道的做完听力要收第一张答题卡&hellip;anyway考得还行，要不是学校大一不统一考我早过了&hellip;
 吃了顿宿舍火锅，去了趟较场尾团建，十二月就这么过去辣！
总结一下  因为本来就对自己没什么期待，找回了自己也算是意料之外的惊喜吧。感想所有关注我，关心我，支持我的人。遗憾就是没能在我以后要从事的专业领域有什么很大的进展，没能参与什么项目开发或科研项目QwQ但在日常用自己的电脑的时候能稍微像程序员一点地去解决一些小问题了&hellip;
 最近在做一个关于大家2020年flag完成情况的采访推文（是官微的啦），立一下2021的flag吧！
真的找时间开放个小东西吧，小程序也行啊(本站也算吧&hellip;哭了&hellip;)
坚持写公众号啊啊
练琴练吉他（这是这几个里最有可能完成的&hellip;
[] 锻炼身体keep fit
最后
该死的2020
fuck off
2021对我好点！
 </content></entry><entry><title>从深中到深技大的校园民主</title><url>https://yinan-hong.github.io/post/campusdemocracy/</url><categories><category>生活杂谈</category></categories><tags><tag>校园民主</tag></tags><content type="html">  本文有很多超链接，在公众号里阅读体验更好噢~点击左侧sidebar，头像下方的微信公众号，扫码关注，回复校园民主。
 本页面中这样的文本为超链接。
 趁着自己还是学生写一篇校园相关的，就感觉讨论自己身边的事，格局有点小，以后大概不会写很多学校的事…没法做到很客观=.=
深圳中学的民主实践  从高中我就一直在思考的问题，什么才是真正的校园民主，什么样的制度能有效地维护学生的权益？
 深中的民主自由也算是一大校园特色了。在深中还有校园民主这回事，是由于学生有维护自己权利的意识，于是在制度制定中有学生的高度参与，也建立了比较完善的反馈机制。很多人连维护自己权利的意识都没有，那也不用谈什么争取民主了。
 另外民主并不是表面的可以带手机不用穿校服=.=
议事会  我大概简化了一下深中的民主体系（我在的时代…）。感觉有点三权分立内味儿…查了下议事会的公众号。议事会通过组织会议，对学校的政策、学生的提议等进行讨论和修改。据我所知，议员由每个班选举产生，每个班两名，然后他们会定期or不定期开会讨论问题。有点民主集中制内味儿了…
 煮个栗子，放个会议记录，是关于修订《深圳中学学生行为指引》的一次会议。
学生会权益部  学生会的权益部是比较有意思的。感觉很多学校的学生会可能只是组织组织活动，我觉得他们没get到学生会的精髓…我在校的时候与学生会的接触比较少，于是搜了下学生会的公众号…
 点进去就能看到挺明显的维权通道，针不戳（有兴趣去翻翻他们的维权案例啊就近期维权申诉公示），随便翻了翻，有篮球场数量不够，灯光布置不合理；小卖部莫名涨价，冰箱不开；食堂菜量莫名减少之类之类的维权案例。收到维权申诉之后，学生会干事会去找相关部门、老师、食堂经理、物业之类的解决问题，并且会公示出申诉内容和处理结果。根据公示出的内容看来，他们确实帮助学生解决了问题。
 虽然看起来这些都是些小问题，吃点小亏就过去了，但小的权益你不维护，谁还指望你去维护大的权益。
 当纳粹来抓共产党人时，我保持沉默，因为我不是共产党人；当他们来抓犹太人时，我保持沉默，因为我不是犹太人；当他们来抓贸易工会主义者时，我保持沉默，因为我不是贸易工会主义者；当他们来抓天主教徒时，我保持沉默，因为我是新教徒；当他们来抓我时，已无人替我说话了。
—— 所以要不要先试着维护一下自己的权利
 我觉得最值得肯定的是学生的维权意识，你要知道去维护自己的权利，才会去找方法，建立这样的制度并维系下去。
18号农场  聊深中民主就免不了想到18号农场。有兴趣可以康康农场宣言。18号农场就是一个匿名的公众号，会发一些对校园时事的见解，接受投稿，所以纯粹为了喷的文章也不少…但还是有很多能引发思考or思想碰撞的文章的。（我i的可不就是深中人思想碰撞的火花）
 负责学生事务的老师是有关注这些文章的，所以学校政策和学生意识出现大的冲突时，一些偏激or客观有用的文字能让老师重新审视政策or制度。
 Btw，这样子学生高度参与的制度是需要老师的支持的，要让老师care你是要自己去争取的，要怎么做到让老师觉得你是在参与校园政治维护学生权益而不是在玩个校园政治过家家是需要努力和脑子的。
 有立法，维权，反馈这些方面，这样的校园民主制度我觉得是很完善的了，在教学之余能完善出这样的制度，我是非常佩服参与过这其中的深中人（不只是深中学子噢）的。
校园民主的误区  学生追求民主是好事，但也容易陷入一些误区，比如过于追求形式，错误地认为民主就是把老师和校方放在对立面。讲个校园民主的反例，就是我高一经历的“校猫听证会”。
 深中有很多猫，我们称它们为校猫。校猫平时是由校猫社和收发室的老师喂养的，猫粮都是师生捐赠的，会众筹给猫绝育、打疫苗，猫生病时也会众筹给它治病。平时猫就在校园里到处游荡，好不快活（校园特色…
 然后就是当年有只猫病了，好像很严重，然后一开始是众筹给猫治病，某学生组织有一直在跟进猫的治疗，时不时会通报一下猫的情况。后来又好像猫病的太严重了，校猫社无法承担医疗费用，且治疗风险很大。于是学生组织就搞了个投票要不要把猫给安乐死。这件事当时争议还挺大的，然后为了做出决定，于是开了个校猫听证会。
 然后在校猫听证会上，我在内的热心群众被宠物医院的兽医大哥喷的狗血淋头，说明明猫是很大概率可以治好的，我们却搞了个安乐死投票，不尊重生命，一般猫遇到这种情况都不会放弃治疗blablabla。然而从当时学生组织的公告和投票的描述来看，大家都以为猫是病得不轻，花几千元都很难治好的，很明显信息传达不到位！！！虽然当场很多学生都解释了信息传达不到位这件事，但兽医大哥还是喷的我很无语…
 这件事是想说，民主实践过程中请带脑子…
 另外，深中有很好的海报文化，学生组织/社团有大的决议、公告等会发布这样的文件，还会张贴在各种楼道、通道的墙上。就很有内味儿！
技大的民主模式雏形  一句话讲完版本：就是没有，希望各位有识之士快来建立。
 技大有学生会，有社联，但好像都是举办活动比较多，跟制度制定，维护学生权益没有很大关系…（虽然也有权益部）新学校，没有也很正常，不过什么社团发篇推文都要经过团委审核我真是闻所未闻，可能我孤陋寡闻了…
关于投诉反馈问题  我觉得现在最需要解决的问题是投诉无门（缺少高效的反馈渠道or反馈石沉大海）（貌似不只有学校存在这样的问题狗头）。有好多事情反馈给老师/物业/饭堂，打打太极就过去了…问题得不到解决。记得我刚来的时候经常说，这样这样要是在深中是分分钟要被挂到18号农场的…当时气的甚至想建立“技大农场”…但我怂…
 想想，如果有个学生组织的学生代表，代表大多数学生，去投诉/反馈一件事，是不是比我一个单一的个体去投诉/反馈要有力得多呢？
校长/书记面对面  技大有校长面对面和书记下午茶（党委书记），好像举办的还挺频繁的，但就是反馈的问题好像都是经过老师筛选的，参会人员也不知道是怎么产生的，真正有问题的问题会不会被掐死在半路呢？感觉就是徒有其表，只学到了个外壳罢了。上次在班里征集问题时征集了一堆，官微发记录推文的时候一个也没有问到…征集的问题貌似也没有再反馈回来。后来想了想，校长面对面这种是宣传意义比较大，因为官微推文在报道校长面对面这些活动时，都是在宣传学校的民生建设，活动制度之类的。
学校政策推行缺少学生参与  1.宿舍运营商只有联通，日常断网，甚至新生入学第一天网炸了，是谁让联通入驻的？跟进一下后期维护呗。（有学生在调查学生对联通的满意度了，兄弟加油！
 2.去年宿舍楼下单车乱放，某天通知都没有，物业就把半个学校的单车挪到另一块地方了，第二天早课到楼下一脸懵逼地在几百辆车里找车。（额今年新生报道前一天挪的那次终于知道要提前说了&hellip;）
 3.去年行业认知课程，学期末倒数第三周突然通知剩下三周每周二下午（工作日唯一大块无课的空余时间）去企业参观，废掉我整个下午大半个晚上。要期末考的好不…且不说参观交流质量有多差…
 4.学期最后一个周末校运会….（就&hellip;原谅我就缺席了呗..
 就，以上稍微征询一下学生意见都不会搞出这么荒唐的事吧…新学校刚起步，说是一天一个样都不过分，趁着各种制度都在完善中，希望各位有识之士快来参与建立好的制度，不要让不好的制度扎根，成为以后的“传统”，这样就难改了。
 迷惑行为大赏就写到这里。反正就，同为深圳市政（财）府（政）的亲儿砸，深圳中学的深中模式值得借鉴…
再多说几句  我觉得大学教育还应该培养学生的公民意识和社会责任，就，大学生这么多，有好多不会做人的…有机会写写讲讲教育问题…
 深中大概每月会有一次公民课堂，在周一集会上举行，会邀请到各种人讲各种事，主讲的人有学生有老师也有学校外的人。虽然公民课堂的效果有好有坏，但这样对学生的公民教育是种不错的尝试。（本想放图但公众号都找不到相关的内容&hellip;）
 我在的深中更像是象牙塔，有引导学生积极尝试的氛围，能包容学生的各种尝试，学生能“试出”真正的自己，成为一个社会中的完整的个体。我想这才是别的学校（国内外都）学不来的深中精神内核，才是打出“世界一流“名号最有力的依据。
Ending  深圳中学致力于培养具有丰富生命里的人。他们能自主发现和实现个人的潜能，成为他们最好的自己，而且他们无论身在何处，都能尊重自然，关爱他人，服务社会，造福世界，并且乐在其中。
——我最喜欢的一个版本，并且一直贴在我桌子上
 </content></entry><entry><title>Markdown语法手册</title><url>https://yinan-hong.github.io/post/markdown-syntax/</url><categories><category>markdown</category></categories><tags><tag>theme</tag></tags><content type="html"> 本文提供了一个可以在Hugo内容文件中使用的基本Markdown语法示例，还展示了基本HTML元素在Hugo主题中是否使用CSS装饰。
Headings The following HTML &lt;h1>—&lt;h6> elements represent six levels of section headings. &lt;h1> is the highest section level while &lt;h6> is the lowest.
H1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.
Itatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.
Blockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.
Blockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.
Blockquote with attribution Don&rsquo;t communicate by sharing memory, share memory by communicating.
— Rob Pike1
Tables Tables aren&rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.
Name Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Code block with backticks &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> Code block indented with four spaces &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> Code block with Hugo&rsquo;s internal highlight shortcode &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.
H2O
Xn + Yn = Zn
Press CTRL+ALT+Delete to end the session.
Most salamanders are nocturnal, and hunt for insects, worms, and other small creatures.
  The above quote is excerpted from Rob Pike&rsquo;s talk during Gopherfest, November 18, 2015. &#8617;&#xfe0e;</content></entry><entry><title>富文本内容测试</title><url>https://yinan-hong.github.io/post/rich-content/</url><categories/><tags><tag>theme</tag></tags><content type="html"> Hugo 雨果附带几个[内置的短码](https://gohugo.io/content-management/shortcodes/ use-hugos-built-in-shortcodes)内容丰富,以及隐私配置和一组简单的短码,使静态和no-JS版本的各种社会媒体嵌入。
YouTube Privacy Enhanced Shortcode Twitter Simple Shortcode .twitter-tweet { font: 14px/1.45 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif; border-left: 4px solid #2b7bb9; padding-left: 1.5em; color: #555; } .twitter-tweet a { color: #2b7bb9; text-decoration: none; } blockquote.twitter-tweet a:hover, blockquote.twitter-tweet a:focus { text-decoration: underline; } “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”
— Jan Tschichold pic.twitter.com/gcv7SrhvJb
&mdash; Graphic Design History (@DesignReviewed) January 17, 2019 Vimeo Simple Shortcode .__h_video { position: relative; padding-bottom: 56.23%; height: 0; overflow: hidden; width: 100%; background: #000; } .__h_video img { width: 100%; height: auto; color: #000; } .__h_video .play { height: 72px; width: 72px; left: 50%; top: 50%; margin-left: -36px; margin-top: -36px; position: absolute; cursor: pointer; }  </content></entry><entry><title>占位符文本显示</title><url>https://yinan-hong.github.io/post/placeholder-text/</url><categories/><tags><tag>markdown</tag></tags><content type="html"> 你对我的心有偏见。我向您保证，我们的生活将不会受到影响，我们的生活将会受到影响。你说你现在住在医院里，因为你的眼睛是透明的，你的眼睛是光明的，你的眼睛是光明的!
Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.
Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt
The Van de Graaf Canon
Mane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.
Iubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.
Eurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.
 </content></entry><entry><title>数据公式设置显示</title><url>https://yinan-hong.github.io/post/math-typesetting/</url><categories/><tags/><content type="html"> Hugo项目中的数学符号可以通过使用第三方JavaScript库来启用。
In this example we will be using KaTeX
Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: {{ if or .Params.math .Site.Params.math }} {{ partial "math.html" . }} {{ end }} To enable KaTex globally set the parameter math to true in a project&rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions
Examples Block math: $$ \varphi = 1+\frac{1} {1+\frac{1} {1+\frac{1} {1+\cdots} } } $$
 </content></entry><entry><title>支持Emoji表情符号</title><url>https://yinan-hong.github.io/post/emoji-support/</url><categories/><tags><tag>markdown</tag></tags><content type="html"> 在Hugo项目中可以通过多种方式启用Emoji。
The emojify function can be called directly in templates or Inline Shortcodes.
To enable emoji globally, set enableEmoji to true in your site&rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.
馃檲 🙈 馃檳 🙉 馃檴 🙊
The Emoji cheat sheet is a useful reference for emoji shorthand codes.
N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.
.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }  </content></entry></search>